ghc-shake

This is a reimplementation of ghc --make using Shake.  It's entirely one
process, so unlike out-of-process Shake, you won't see any slowdown
compared to --make if you compile with only one core.

# What's the benefit?

    1. You get faster rebuild checking, because Shake doesn't
    recompute the entire dependency graph (ghc --make must
    preprocess and parse all source code every time it loads.)

    2. You can keep going even when one file fails to compile,
    making sure that anything can be built, is built.

    3. You get all the nice Shake features, e.g. estimated
    completion time and profiling.  The profiling is really
    handy!

# How do I use it?

Currently, I'm testing on a very specific configuration:

    - GHC with frontend plugins.  A sufficiently recent
      GHC HEAD will suffice.

    - Cabal with nix-local-build.  Get it here:
        https://github.com/haskell/cabal/tree/nix-local-build

    - Shake with some bugfixes.

Once you've installed that GHC, make two symlinks in this directory, ghc
and ghc-pkg, which point to the version of GHC you want to use.  If you've
added that GHC to your path, these commands will do:

    ln -s `which ghc` ghc
    ln -s `which ghc-pkg` ghc-pkg

Next, you need to get ghc-shake into your local package database.
Easiest way is to create a project.cabal that contains the
projects you want to build as well as ghc-shake.  Then you can say:

    cabal new-build ghc-shake
    cabal new-build other-project -w ghc-shake

(Assuming ghc-shake is in your path.)

# What doesn't work

    1. Linking things that are not executables

    2. Profiling (this is a limitation of GHC's plugins support.)

    3. Some odd edge-cases for output files in --make (especially
    for file targets).

If you need something, shout and I'll try to implement it.

# Known recompilation bugs

We reimplement GHC's recompilation avoidance: if GHC would
have reported, "compilation is NOT necessary", our goal is
to just skip the module entirely.

There are some bits we haven't gotten around to implementing
yet:

    - If you change the package database flags / modify
      the package database, we may fail to pick up the
      changes which cause different interface files to
      be loaded.  (However, we WILL pick up changes to
      the interface files themselves, so long as they
      are in the same place.)
